# MarkoVerse
MarkoVerse — это вероятностный язык программирования, в котором программы являются сочетаниями правил перезаписи, а инференс выполняется при помощи распространения ограничений.

Проект создавался на основе языка MarkovJunior. Можно сказать, MarkoVerse — диалект MarkovJunior.

## Принцип работы
1. MarkoVerse описывает поведение программ как список правил замены вида A=B, где A и B — строки — шаблоны символов.
2. На каждом шаге интерпретатор ищет первое подходящее правило и применяет его к случайному совпадению.
3. Программа останавливается, когда ни одно правило больше не применимо.
4. В двумерном пространстве каждый ряд и столбец рассматривается как независимые строки.

# Интерпретатор
## Служебные классы
### Pair
Простой объект пары. `Pair` используется во множестве объектов.
```java
public class Pair<T, S>{
    T first;
    S second;
    public Pair(T first, S second){
        this.first = first;
        this.second = second;
    }

    public T getFirst() {
        return  first;
    }

    public S getSecond() {
        return second;
    }
}

```
### AhoCorasick

Класс `AhoCorasick` реализует эффективный алгоритм многоперового поиска подстрок (Aho–Corasick), позволяющий искать множество шаблонов в тексте за линейное время.

#### Методы

##### `void insert(String word, int index)`

Добавляет шаблон `word` в дерево поиска с индексом `index`.

> Индекс используется как приоритет (меньше — выше).

##### `void build()`

Строит автомат Aho–Corasick: вычисляет `failLink` для всех узлов и формирует таблицу выхода.

##### `List<Pair<Integer, Integer>> search(String text)`

Выполняет поиск всех вхождений шаблонов в строке `text`.
Возвращает список пар `<позиция, индекс_шаблона>` с минимальным индексом (наивысшим приоритетом).
Если совпадений нет — возвращает `(-1, -1)`.

#### Пример использования:

```java
AhoCorasick ac = new AhoCorasick();
ac.insert("abc", 0);
ac.insert("bc", 1);
ac.build();
List<Pair<Integer, Integer>> matches = ac.search("xabc");
```

### Markov

Класс `Markov` реализует механизм поиска по правилам с использованием автомата Aho–Corasick и случайного выбора совпадений. Поддерживает как одномерные, так и двумерные строки (матрицы символов).

#### Конструкторы

* **`Markov()`** — создаёт объект с неинициализированным генератором случайных чисел.
* **`Markov(int seed)`** — создаёт объект с фиксированным `seed` для детерминированного выбора совпадений.

#### Методы

##### `void insert(String word, int index)`

Добавляет шаблон `word` с приоритетом `index` во внутренний Aho–Corasick автомат.

##### `void build()`

Строит отказоустойчивые ссылки и выходы для всех узлов автомата.

##### `Pair<Integer, Integer> search(String text)`

Находит все вхождения шаблонов в строку `text` и возвращает **одно случайное** совпадение в формате:

* `Pair<позиция, индекс_шаблона>`

##### `int[] search(char[][] matrix)`

Расширенный поиск по двумерной матрице символов. Ищет шаблоны по всем строкам и столбцам (включая обратные направления).
Возвращает массив `int[4]`:

* `[rule_id, row_index, column_index, direction]`, где `direction ∈ {0, 1, 2, 3}`:

  * `0` — снизу вверх
  * `1` — сверху вниз
  * `2` — справа налево
  * `3` — слева направо
    Если совпадений нет — возвращает `{-1, -1, -1, -1}`.


## Публичные классы
### MarkoVerse

Класс `MarkoVerse` реализует однонаправленную систему строковых переписей по заданным правилам, используя автомат Ахо-Корасика для эффективного поиска применимых шаблонов. Поддерживает итеративное применение правил с ограничением по числу шагов.

#### Конструктор

Класс не требует параметров для создания.

#### Методы

##### `void build(String input_word, List<Pair<String, String>> rules)`

Инициализирует начальное слово и список правил переписывания. Каждое правило должно иметь одинаковую длину левой и правой части. Правила индексируются и передаются в автомат `Markov`.

##### `boolean update()`

Применяет одно правило, если находится подходящее вхождение. Ищется первое по приоритету совпадение, которое заменяется. Возвращает `false`, если ни одно правило не может быть применено.

##### `void set_limit(int limit)`

Устанавливает максимальное количество итераций для метода `run()`.

##### `String get_current_word()`

Возвращает текущее состояние строки.

##### `String run()`

Запускает итеративное применение правил до исчерпания возможных совпадений или превышения лимита. Возвращает финальное состояние строки. Если лимит превышен — выбрасывает исключение.

#### Примечания

* Все правила должны быть одинаковой длины слева и справа.
* Метод `run()` является основным способом запуска интерпретации.
* Основан на автомате `Markov`, который использует Aho–Corasick для поиска шаблонов.


### MarkoVerse2D

Класс `MarkoVerse2D` реализует двумерную версию строковой системы переписывания Маркова. Он применяет правила преобразования к символам в матрице, поддерживая поиск шаблонов в четырёх направлениях: вверх, вниз, влево и вправо.

#### Конструктор

Класс не требует параметров для создания.

#### Методы

##### `void build(char[][] input_word, List<Pair<String, String>> rules)`

Инициализирует входную матрицу символов и список правил переписывания. Каждое правило должно иметь равную длину шаблона и замены. Шаблоны передаются в автомат поиска.

##### `boolean update()`

Выполняет один шаг переписывания, если находится подходящее вхождение. Производит замену согласно направлению (вверх, вниз, влево, вправо). Возвращает `false`, если ни одно правило не может быть применено.

##### `void set_limit(int limit)`

Устанавливает ограничение на количество итераций метода `run()`.

##### `char[][] get_current_word()`

Возвращает текущую матрицу символов.

##### `char[][] run()`

Запускает итеративное применение правил до стабилизации или достижения лимита. Если лимит превышен — выбрасывает исключение. Возвращает итоговую матрицу.

## BuiltinServer
Класс `BuiltinServer` реализует простой наблюдатель за файлом `input.json`, ожидающий изменений в режиме реального времени. При обнаружении модификации или создания файла, он считывает данные, применяет правила переписывания к 2D-матрице с использованием `MarkoVerse2D` и подготавливает результат к последующей записи в `output.json`.

### `main-функция`

Вызывается при сборке проекта.

* Запускает файловый наблюдатель (`WatchService`) для директории, содержащей `input.json`.
* При любом событии `ENTRY_CREATE` или `ENTRY_MODIFY`, связанном с файлом `input.json`, вызывает метод `readJsonFile(.)`.
* Работает в бесконечном цикле до прерывания или ошибки.

### Специальные классы

#### `InputData`

* Хранит:

  * `String name` — имя сценария (пока не используется).
  * `List<List<Integer>> word` — матрица символов, представленных как коды `int`.
  * `List<Rule> rules` — список правил переписывания.

* Метод `getWordAsCharArray()` возвращает `char[][]`, необходимый для работы `MarkoVerse2D`.

#### `Rule`

* Простая структура с двумя строками:

  * `pattern` — шаблон для поиска.
  * `replacement_string` — строка-замена.
* Переопределён метод `toString()` для отладки.
